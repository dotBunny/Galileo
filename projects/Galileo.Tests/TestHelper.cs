using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using Xunit;

namespace Galileo.Tests
{
    /// <summary>
    /// Helper functions to be used by the Unit Tests
    /// </summary>
    public static class TestHelper
    {
        /// <summary>
        /// Cached base path used by tests.
        /// </summary>
        /// <returns>The test runner path.</returns>
        public static string TestRunnerPath { get; private set; }
        
        /// <summary>
        /// Temp base path used by tests.
        /// </summary>
        /// <returns>The test runner path.</returns>
        public static string TempRunnerPath { get; private set; }
   
        /// <summary>
        /// Returns the path of a file in the tests resources
        /// </summary>
        /// <returns>The full path to the file</returns>
        /// <param name="file">Specified file to build path with</param>
        public static string GetResourceContentPath(string file)
        {
            // Do we need to cache the path?
            if ( string.IsNullOrEmpty(TestRunnerPath)) {
                TestRunnerPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
            }
            return Path.Combine(TestRunnerPath, "Resources", file);
        }
        
        /// <summary>
        /// Returns the path of a file in temp folder
        /// </summary>
        /// <returns>The full path to the file</returns>
        /// <param name="file">Specified file path for a temporary file</param>
        public static string GetTempPath(string file)
        {
            // Do we need to cache the path?
            if ( string.IsNullOrEmpty(TempRunnerPath)) {
                TempRunnerPath = Path.GetTempPath();
            }
            return Path.Combine(TempRunnerPath, file);
        }

        public static string GetTempFilePath(string extension)
        {
          return GetTempPath(string.Format("{0}.{1}", Path.GetRandomFileName(), extension));
        }

        public static void AssertForWordFiles(string path1, string path2)
        {
            byte[] wordA = File.ReadAllBytes(path1);
            byte[] wordB = File.ReadAllBytes(path2);
            
            // Mostly from:
            // https://stackoverflow.com/questions/8244917/programmatically-comparing-word-documents
            using (var streamA = new MemoryStream(wordA))
            using (var streamB = new MemoryStream(wordB))
            using (var zipA = new ZipArchive(streamA))
            using (var zipB = new ZipArchive(streamB))
            {
                streamA.Seek(0, SeekOrigin.Begin);
                streamB.Seek(0, SeekOrigin.Begin);

                Assert.True(zipA.Entries.Count > 0);
                Assert.True(zipB.Entries.Count > 0);
                Assert.True(zipA.Entries.Count == zipB.Entries.Count);

                for(int i = 0; i < zipA.Entries.Count; ++i)
                {
                    Assert.Equal(zipA.Entries[i].Name, zipB.Entries[i].Name);

                    if (zipA.Entries[i].Name.EndsWith(".rels")) //These are some weird word files with autogenerated hashes
                    {
                        continue;
                    }

                    var streamFromA = zipA.Entries[i].Open();
                    var streamFromB = zipB.Entries[i].Open();

                    using (var readerA = new StreamReader(streamFromA))
                    using (var readerB = new StreamReader(streamFromB))
                    {
                        var bytesA = readerA.ReadToEnd();
                        var bytesB = readerB.ReadToEnd();
                        Assert.NotEmpty(bytesA);
                        Assert.NotEmpty(bytesB);
                        Assert.Equal(bytesA.Length, bytesB.Length);

                        Assert.Equal(bytesA, bytesB);
                    }
                }
                
            }
        }

    }
    
}
